/**
 * Lenis v1.0.27 - Smooth scroll library
 * https://github.com/studio-freight/lenis
 */

(function (global, factory) {
  // UMD (Universal Module Definition) 패턴
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define(factory);
  } else {
    (global || self).Lenis = factory();
  }
}(this, function () {
  'use strict';

  // 유틸리티 함수들
  function defineProperties(target, props) {
    for (let i = 0; i < props.length; i++) {
      const descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  function createClass(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }

  function _extends() {
    return Object.assign || function (target) {
      for (let i = 1; i < arguments.length; i++) {
        const source = arguments[i];
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
  }

  function clamp(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }

  function toPropertyKey(arg) {
    const key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    const prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      const res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  /**
   * Animate 클래스 - 값 애니메이션을 담당
   */
  class Animate {
    advance(deltaTime) {
      if (!this.isRunning) return;

      let completed = false;

      if (this.lerp) {
        // Lerp (선형 보간) 방식
        this.value = lerp(this.value, this.to, 1 - Math.exp(-60 * this.lerp * deltaTime));
        if (Math.round(this.value) === this.to) {
          this.value = this.to;
          completed = true;
        }
      } else {
        // Duration 기반 애니메이션
        this.currentTime += deltaTime;
        const progress = clamp(0, this.currentTime / this.duration, 1);
        completed = progress >= 1;
        const eased = completed ? 1 : this.easing(progress);
        this.value = this.from + (this.to - this.from) * eased;
      }

      this.onUpdate?.(this.value, completed);
      if (completed) this.stop();
    }

    stop() {
      this.isRunning = false;
    }

    fromTo(from, to, options = {}) {
      const {
        lerp = 0.1,
        duration = 1,
        easing = t => t,
        onStart,
        onUpdate
      } = options;

      this.from = this.value = from;
      this.to = to;
      this.lerp = lerp;
      this.duration = duration;
      this.easing = easing;
      this.currentTime = 0;
      this.isRunning = true;

      onStart?.();
      this.onUpdate = onUpdate;
    }
  }

  /**
   * Dimensions 클래스 - 크기 측정 및 관리
   */
  class Dimensions {
    constructor({ wrapper, content, autoResize = true } = {}) {
      this.wrapper = wrapper;
      this.content = content;

      if (autoResize) {
        this.resize = debounce(this.resize.bind(this), 250);
        
        if (this.wrapper !== window) {
          this.wrapperResizeObserver = new ResizeObserver(this.resize);
          this.wrapperResizeObserver.observe(this.wrapper);
        }
        
        this.contentResizeObserver = new ResizeObserver(this.resize);
        this.contentResizeObserver.observe(this.content);
      }

      this.resize();
    }

    destroy() {
      this.wrapperResizeObserver?.disconnect();
      this.contentResizeObserver?.disconnect();
    }

    resize() {
      this.onWrapperResize();
      this.onContentResize();
    }

    onWrapperResize() {
      if (this.wrapper === window) {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
      } else {
        this.width = this.wrapper.clientWidth;
        this.height = this.wrapper.clientHeight;
      }
    }

    onContentResize() {
      this.scrollHeight = this.content.scrollHeight;
      this.scrollWidth = this.content.scrollWidth;
    }

    get limit() {
      return {
        x: this.scrollWidth - this.width,
        y: this.scrollHeight - this.height
      };
    }
  }

  /**
   * Emitter 클래스 - 이벤트 관리
   */
  class Emitter {
    constructor() {
      this.events = {};
    }

    emit(event, ...args) {
      const callbacks = this.events[event] || [];
      for (let i = 0, len = callbacks.length; i < len; i++) {
        callbacks[i](...args);
      }
    }

    on(event, callback) {
      if (!this.events[event]) {
        this.events[event] = [];
      }
      this.events[event].push(callback);

      // unsubscribe 함수 반환
      return () => {
        this.events[event] = this.events[event]?.filter(cb => cb !== callback);
      };
    }

    off(event, callback) {
      this.events[event] = this.events[event]?.filter(cb => cb !== callback);
    }

    destroy() {
      this.events = {};
    }
  }

  /**
   * VirtualScroll 클래스 - 스크롤 이벤트 정규화
   */
  class VirtualScroll {
    constructor(element, options = {}) {
      const {
        wheelMultiplier = 1,
        touchMultiplier = 2,
        normalizeWheel = false
      } = options;

      this.element = element;
      this.wheelMultiplier = wheelMultiplier;
      this.touchMultiplier = touchMultiplier;
      this.normalizeWheel = normalizeWheel;
      
      this.touchStart = { x: null, y: null };
      this.emitter = new Emitter();

      // 이벤트 리스너 등록
      this.element.addEventListener('wheel', this.onWheel, { passive: false });
      this.element.addEventListener('touchstart', this.onTouchStart, { passive: false });
      this.element.addEventListener('touchmove', this.onTouchMove, { passive: false });
      this.element.addEventListener('touchend', this.onTouchEnd, { passive: false });
    }

    on(event, callback) {
      return this.emitter.on(event, callback);
    }

    destroy() {
      this.emitter.destroy();
      this.element.removeEventListener('wheel', this.onWheel, { passive: false });
      this.element.removeEventListener('touchstart', this.onTouchStart, { passive: false });
      this.element.removeEventListener('touchmove', this.onTouchMove, { passive: false });
      this.element.removeEventListener('touchend', this.onTouchEnd, { passive: false });
    }

    onTouchStart = (event) => {
      const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;
      this.touchStart.x = clientX;
      this.touchStart.y = clientY;
      this.lastDelta = { x: 0, y: 0 };
    }

    onTouchMove = (event) => {
      const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;
      
      const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier;
      const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier;
      
      this.touchStart.x = clientX;
      this.touchStart.y = clientY;
      this.lastDelta = { x: deltaX, y: deltaY };
      
      this.emitter.emit('scroll', { deltaX, deltaY, event });
    }

    onTouchEnd = (event) => {
      this.emitter.emit('scroll', {
        deltaX: this.lastDelta.x,
        deltaY: this.lastDelta.y,
        event
      });
    }

    onWheel = (event) => {
      let { deltaX, deltaY } = event;
      
      if (this.normalizeWheel) {
        deltaX = clamp(-100, deltaX, 100);
        deltaY = clamp(-100, deltaY, 100);
      }
      
      deltaX *= this.wheelMultiplier;
      deltaY *= this.wheelMultiplier;
      
      this.emitter.emit('scroll', { deltaX, deltaY, event });
    }
  }

  /**
   * Lenis 메인 클래스
   */
  class Lenis {
    constructor(options = {}) {
      // 버전 정보
      window.lenisVersion = '1.0.27';

      // 옵션 초기화
      const {
        wrapper = window,
        content = document.documentElement,
        wheelEventsTarget = wrapper,
        eventsTarget = wheelEventsTarget,
        smoothWheel = true,
        smoothTouch = false,
        syncTouch = false,
        syncTouchLerp = 0.1,
        __iosNoInertiaSyncTouchLerp = 0.4,
        touchInertiaMultiplier = 35,
        duration,
        easing = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
        lerp = !duration && 0.1,
        infinite = false,
        orientation = 'vertical', // 'vertical' | 'horizontal'
        gestureOrientation = 'vertical', // 'vertical' | 'horizontal' | 'both'
        touchMultiplier = 1,
        wheelMultiplier = 1,
        normalizeWheel = false,
        autoResize = true
      } = options;

      // wrapper가 document element나 body인 경우 window로 설정
      if (wrapper !== document.documentElement && wrapper !== document.body) {
        this.wrapper = wrapper;
      } else {
        this.wrapper = window;
      }

      // 옵션 저장
      this.options = {
        wrapper: this.wrapper,
        content,
        wheelEventsTarget,
        eventsTarget,
        smoothWheel,
        smoothTouch,
        syncTouch,
        syncTouchLerp,
        __iosNoInertiaSyncTouchLerp,
        touchInertiaMultiplier,
        duration,
        easing,
        lerp,
        infinite,
        gestureOrientation,
        orientation,
        touchMultiplier,
        wheelMultiplier,
        normalizeWheel,
        autoResize
      };

      // 인스턴스 초기화
      this.animate = new Animate();
      this.emitter = new Emitter();
      this.dimensions = new Dimensions({ wrapper: this.wrapper, content, autoResize });
      
      // 상태 초기화
      this.toggleClass('lenis', true);
      
      this.velocity = 0;
      this.isLocked = false;
      this.isStopped = false;
      this.isSmooth = syncTouch || smoothWheel || smoothTouch;
      this.isScrolling = false;
      this.targetScroll = this.animatedScroll = this.actualScroll;

      // 이벤트 리스너 설정
      this.options.wrapper.addEventListener('scroll', this.onScroll, { passive: false });
      
      // 가상 스크롤 설정
      this.virtualScroll = new VirtualScroll(eventsTarget, {
        touchMultiplier,
        wheelMultiplier,
        normalizeWheel
      });
      this.virtualScroll.on('scroll', this.onVirtualScroll);
    }

    destroy() {
      this.emitter.destroy();
      this.options.wrapper.removeEventListener('scroll', this.onScroll, { passive: false });
      this.virtualScroll.destroy();
      this.dimensions.destroy();
      
      this.toggleClass('lenis', false);
      this.toggleClass('lenis-smooth', false);
      this.toggleClass('lenis-scrolling', false);
      this.toggleClass('lenis-stopped', false);
      this.toggleClass('lenis-locked', false);
    }

    on(event, callback) {
      return this.emitter.on(event, callback);
    }

    off(event, callback) {
      return this.emitter.off(event, callback);
    }

    setScroll(scroll) {
      if (this.isHorizontal) {
        this.rootElement.scrollLeft = scroll;
      } else {
        this.rootElement.scrollTop = scroll;
      }
    }

    resize() {
      this.dimensions.resize();
    }

    emit() {
      this.emitter.emit('scroll', this);
    }

    reset() {
      this.isLocked = false;
      this.isScrolling = false;
      this.velocity = 0;
      this.animate.stop();
    }

    start() {
      this.isStopped = false;
      this.reset();
    }

    stop() {
      this.isStopped = true;
      this.animate.stop();
      this.reset();
    }

    raf(time) {
      const deltaTime = time - (this.time || time);
      this.time = time;
      this.animate.advance(deltaTime * 0.001);
    }

    scrollTo(target, options = {}) {
      const {
        offset = 0,
        immediate = false,
        lock = false,
        duration = this.options.duration,
        easing = this.options.easing,
        lerp = !duration && this.options.lerp,
        onComplete = null,
        force = false,
        programmatic = true
      } = options;

      if ((this.isStopped || this.isLocked) && !force) return;

      // 타겟 처리
      if (['top', 'left', 'start'].includes(target)) {
        target = 0;
      } else if (['bottom', 'right', 'end'].includes(target)) {
        target = this.limit;
      } else {
        let node;
        
        if (typeof target === 'string') {
          node = document.querySelector(target);
        } else if (target?.nodeType) {
          node = target;
        }

        if (node) {
          if (this.options.wrapper !== window) {
            const wrapperRect = this.options.wrapper.getBoundingClientRect();
            offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;
          }

          const rect = node.getBoundingClientRect();
          target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;
        }
      }

      if (typeof target !== 'number') return;

      target += offset;
      target = Math.round(target);

      if (this.options.infinite) {
        if (programmatic) {
          this.targetScroll = this.animatedScroll = this.scroll;
        }
      } else {
        target = clamp(0, target, this.limit);
      }

      if (immediate) {
        this.animatedScroll = this.targetScroll = target;
        this.setScroll(this.scroll);
        this.reset();
        onComplete?.(this);
        return;
      }

      if (!programmatic) {
        if (target === this.targetScroll) return;
        this.targetScroll = target;
      }

      this.animate.fromTo(this.animatedScroll, target, {
        duration,
        easing,
        lerp,
        onStart: () => {
          if (lock) this.isLocked = true;
          this.isScrolling = true;
        },
        onUpdate: (value, completed) => {
          this.isScrolling = true;
          this.velocity = value - this.animatedScroll;
          this.direction = Math.sign(this.velocity);
          this.animatedScroll = value;
          this.setScroll(this.scroll);
          
          if (programmatic) {
            this.targetScroll = value;
          }

          if (!completed) {
            this.emit();
          }

          if (completed) {
            requestAnimationFrame(() => {
              this.reset();
              this.emit();
              onComplete?.(this);
            });
          }
        }
      });
    }

    toggleClass(className, force) {
      this.rootElement.classList.toggle(className, force);
      this.emitter.emit('className change', this);
    }

    // 가상 스크롤 이벤트 핸들러
    onVirtualScroll = ({ deltaX, deltaY, event }) => {
      if (event.ctrlKey) return;

      const isTouch = event.type.includes('touch');
      const isWheel = event.type.includes('wheel');

      // 방향 체크
      if (this.options.gestureOrientation === 'both' && deltaX === 0 && deltaY === 0) return;
      if (this.options.gestureOrientation === 'vertical' && deltaY === 0) return;
      if (this.options.gestureOrientation === 'horizontal' && deltaX === 0) return;

      // 터치에서 맨 위에서 더 이상 올라가려고 할 때 방지
      if (isTouch && this.options.gestureOrientation === 'vertical' && 
          this.scroll === 0 && !this.options.infinite && deltaY <= 0) return;

      // data-lenis-prevent 체크
      const composedPath = event.composedPath();
      const path = composedPath.slice(0, composedPath.indexOf(this.rootElement));
      
      const preventFound = path.find(node => {
        return node.hasAttribute?.('data-lenis-prevent') ||
               (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||
               (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||
               node.classList?.contains('lenis');
      });

      if (preventFound) return;

      if (this.isStopped || this.isLocked) {
        event.preventDefault();
        return;
      }

      this.isSmooth = ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||
                      (this.options.smoothWheel && isWheel);

      if (!this.isSmooth) {
        this.isScrolling = false;
        this.animate.stop();
        return;
      }

      event.preventDefault();

      let delta = deltaY;
      if (this.options.gestureOrientation === 'both') {
        delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;
      } else if (this.options.gestureOrientation === 'horizontal') {
        delta = deltaX;
      }

      const syncTouch = isTouch && this.options.syncTouch;
      const hasTouchInertia = isTouch && event.type === 'touchend' && Math.abs(delta) > 1;

      if (hasTouchInertia) {
        delta = this.velocity * this.options.touchInertiaMultiplier;
      }

      this.scrollTo(this.targetScroll + delta, {
        programmatic: false,
        ...(syncTouch && {
          lerp: hasTouchInertia ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp
        })
      });
    }

    // 네이티브 스크롤 이벤트 핸들러
    onScroll = () => {
      if (this.isScrolling) return;

      const prevAnimatedScroll = this.animatedScroll;
      this.animatedScroll = this.targetScroll = this.actualScroll;
      this.velocity = 0;
      this.direction = Math.sign(this.animatedScroll - prevAnimatedScroll);
      this.emit();
    }

    // Getters
    get rootElement() {
      return this.options.wrapper === window ? this.options.content : this.options.wrapper;
    }

    get limit() {
      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y'];
    }

    get isHorizontal() {
      return this.options.orientation === 'horizontal';
    }

    get actualScroll() {
      return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;
    }

    get scroll() {
      return this.options.infinite
        ? modulo(this.animatedScroll, this.limit)
        : this.animatedScroll;
    }

    get progress() {
      return this.limit === 0 ? 1 : this.scroll / this.limit;
    }

    get isSmooth() {
      return this.__isSmooth;
    }

    set isSmooth(value) {
      if (this.__isSmooth !== value) {
        this.__isSmooth = value;
        this.toggleClass('lenis-smooth', value);
      }
    }

    get isScrolling() {
      return this.__isScrolling;
    }

    set isScrolling(value) {
      if (this.__isScrolling !== value) {
        this.__isScrolling = value;
        this.toggleClass('lenis-scrolling', value);
      }
    }

    get isStopped() {
      return this.__isStopped;
    }

    set isStopped(value) {
      if (this.__isStopped !== value) {
        this.__isStopped = value;
        this.toggleClass('lenis-stopped', value);
      }
    }

    get isLocked() {
      return this.__isLocked;
    }

    set isLocked(value) {
      if (this.__isLocked !== value) {
        this.__isLocked = value;
        this.toggleClass('lenis-locked', value);
      }
    }

    get className() {
      let className = 'lenis';
      if (this.isStopped) className += ' lenis-stopped';
      if (this.isLocked) className += ' lenis-locked';
      if (this.isScrolling) className += ' lenis-scrolling';
      if (this.isSmooth) className += ' lenis-smooth';
      return className;
    }
  }

  // Helper functions
  function lerp(start, end, amount) {
    return (1 - amount) * start + amount * end;
  }

  function modulo(value, limit) {
    return ((value % limit) + limit) % limit;
  }

  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  return Lenis;
}));